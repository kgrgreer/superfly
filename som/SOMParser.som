SOMParser = Grammar (
  "translated from: https://github.com/SOM-st/SOM/blob/master/specification/SOM.g4"

  classdef = ( ^
    (self Identifier) , (self Equal) , (self superclass) ,
    (self instanceFields) , (self method) star ,
    ( (self Separator) , (self classFields) , ((self method)  star) ) optional ,
    (self EndTerm)
  )

  superclass = ( ^
    (self Identifier) optional , (self NewTerm)
  )

  instanceFields = ( ^
    ( (self Or) , (self variable) star , (self Or) ) optional
  )

  classFields = ( ^
    ( (self Or) , (self variable) star , (self Or) ) optional
  )

  method = ( ^
    (self pattern) , (self Equal) , ( self Primitive || self methodBlock )
  )

  pattern = ( ^
    (self unaryPattern) || (self keywordPattern) || (self binaryPattern)
  )

  unaryPattern = ( ^ (self unarySelector) )

  binaryPattern = ( ^ (self binarySelector) , (self argument) )

  keywordPattern = ( ^
    ( (self keyword) , (self argument) ) plus
  )

  methodBlock = ( ^
    (self NewTerm) , ((self blockContents) optional), (self EndTerm)
  )

  unarySelector = ( ^ (self identifier) )

  binarySelector = ( ^
    (self Or)   || (self Comma) || (self Minus) || (self Equal) || (self Not)  ||
    (self And)  || (self Star)  || (self Div)   || (self Mod)   || (self Plus) ||
    (self More) || (self Less)  || (self At)    || (self Per)   || (self OperatorSequence)
  )

  identifier = ( ^ (self Primitive) || (self Identifier) )

  keyword = ( ^ (self Keyword) )

  argument = ( ^ (self variable) )

  blockContents = ( ^
    ( (self Or) , (self localDefs) , (self Or) ) optional , (self blockBody)
  )

  localDefs = ( ^ (self variable) star )

  blockBody = ( ^
    (self Exit) , (self result) ||
    ((self expression) , ( (self Period) , ((self sym: #blockBody) optional)) optional)
  )

  result = ( ^
    (self expression) , ((self Period) optional)
  )

  expression = ( ^ (self assignation) || (self evaluation) )

  assignation = ( ^ (self assignments) , (self evaluation) )

  assignments = ( ^ (self assignment) , (self plus) )

  assignment = ( ^ (self variable) , (self Assign) )

  evaluation = ( ^ (self primary) , (self messages) optional )

  primary = ( ^
    (self variable)    ||
    (self sym: #nestedTerm)  ||
    (self sym: #nestedBlock) ||
    (self literal)
  )

  variable = ( ^ (self identifier) )

  messages = ( ^
    (
      ((self unaryMessage) plus) ,
      ((self binaryMessage) star) ,
      ((self keywordMessage) optional)
    ) ||
    (((self binaryMessage) plus) , ((self keywordMessage) optional)) ||
    (self keywordMessage)
  )

  unaryMessage = ( ^ (self unarySelector) )

  binaryMessage = ( ^ (self binarySelector) , (self binaryOperand) )

  binaryOperand = ( ^ (self primary) , (self unaryMessage) star)

  keywordMessage = ( ^ ( (self keyword) , (self formula) ) plus )

  formula = ( ^ (self binaryOperand) , (self binaryMessage) star )

  nestedTerm = ( ^
    (self NewTerm) , (self sym: #expression) , (self EndTerm)
  )

  literal = ( ^
    (self sym: #literalArray)  ||
    (self literalSymbol) ||
    (self literalString) ||
    (self literalNumber)
  )

  literalArray = ( ^
    (self Pound) ,
    (self NewTerm) ,
      ((self sym: #literal) star) ,
    (self EndTerm)
  )

  literalNumber = ( ^ (self negativeDecimal) || (self literalDecimal) )

  literalDecimal = ( ^ (self literalDouble) || (self literalInteger) )

  negativeDecimal = ( ^ (self Minus) , (self literalDecimal) )

  literalInteger = ( ^ (self Integer) )

  literalDouble = ( ^ (self Double) )

  literalSymbol = ( ^ (self Pound) , ( (self string) || (self selector) ))

  literalString = ( ^ (self string) )

  selector = ( ^ (self binarySelector) || (self keywordSelector) || (self unarySelector))

  keywordSelector = ( ^ (self Keyword) || (self KeywordSequence) )

  string = ( ^ (self STString) )

  nestedBlock = ( ^
    (self NewBlock) ,
      ((self sym: #blockPattern) optional) ,
      ((self sym: #blockContents) optional) ,
    (self EndBlock)
  )

  blockPattern = ( ^ (self blockArguments) , (self Or) )

  blockArguments = ( ^ ((self Colon) , (self argument)) plus )

  Integer = ( ^ self nt: self Num plus )

  Double = ( ^ self nt: self Num plus , '.' , self Num plus )

  Alpha = ( ^ (Range from: 'a' to: 'z') || (Range from: 'A' to: 'Z') )

  Num = ( ^ Range from: '0' to: '9' )

  AlphaNum = ( ^ (self Alpha) || (self Num) )

  Identifier = ( ^ self nt: (self Alpha) , ((self AlphaNum) star) )

  Primitive = ( ^ self nt: 'primitive' )

  Separator = ( ^ self nt: (Repeat parser: '-' min: 4) )

  Equal    = ( ^ self nt: '='  )
  NewTerm  = ( ^ self nt: '('  )
  EndTerm  = ( ^ self nt: ')'  )
  Or       = ( ^ self nt: '|'  )
  Comma    = ( ^ self nt: ','  )
  Minus    = ( ^ self nt: '-'  )
  Not      = ( ^ self nt: '~'  )
  And      = ( ^ self nt: '&'  )
  Star     = ( ^ self nt: '*'  )
  Div      = ( ^ self nt: '/'  )
  Mod      = ( ^ self nt: '\\' )
  Plus     = ( ^ self nt: '+'  )
  More     = ( ^ self nt: '>'  )
  Less     = ( ^ self nt: '<'  )
  At       = ( ^ self nt: '@'  )
  Per      = ( ^ self nt: '%'  )
  Colon    = ( ^ self nt: ':'  )
  NewBlock = ( ^ self nt: '['  )
  EndBlock = ( ^ self nt: ']'  )
  Pound    = ( ^ self nt: '#'  )
  Exit     = ( ^ self nt: '^'  )
  Period   = ( ^ self nt: '.'  )
  Assign   = ( ^ self nt: ':=' )

  OperatorSequence = ( ^
    (
      (self Not)   || (self And)  || (self Or)    || (self Star) || (self Div)  ||
      (self Mod)   || (self Plus) || (self Equal) || (self More) || (self Less) ||
      (self Comma) || (self At)   || (self Per)   || (self Minus)
    ) plus
  )

  Keyword = ( ^ self nt: (self Identifier) , (self Colon) )

  KeywordSequence = ( ^ (self Keyword) plus )

  STStringChar = ( ^
    (Literal new: '\\t')  ||
    (Literal new: '\\b')  ||
    (Literal new: '\\n')  ||
    (Literal new: '\\r')  ||
    (Literal new: '\\f')  ||
    (Literal new: '\\0')  ||
    (Literal new: '\\\'') ||
    (Literal new: '\\\\') ||
    (NotChars new: '\\\'')
  )

  STString = ( ^ self nt:
    ((Literal new: '\'') , ((self STStringChar) star) , '\'')
  )


  Comment = ( ^ (Literal new: '"') , ((NotChars new: '"') star) , '"' )

  Whitespace = ( ^ ((Literal new: ' ') || '\t' || '\r' || '\n') plus )

  SKIP = ( ^ ((self Whitespace) || (self Comment)) star )

----

)
