SOMParser = Grammar (
  "translated from: https://github.com/SOM-st/SOM/blob/master/specification/SOM.g4"

  classdef = ( ^
    self Identifier , self Equal , self superclass ,
    self NewTerm ,
      self instanceFields ,
      self method star ,
      (
        self Separator ,
        self classFields ,
        (self method star)
      ) optional ,
    self EndTerm
  )

  superclass = ( ^
    self Identifier optional
  )

  instanceFields = ( ^
    ( self Or , self variable star , self Or ) optional
  )

  classFields = ( ^
    ( self Or , self variable star , self Or ) optional
  )

  method = ( ^
    self pattern , self Equal , ( self STPrimitive || self methodBlock )
  )

  pattern = ( ^
    self unaryPattern || self keywordPattern || self binaryPattern
  )

  unaryPattern = ( ^ self unarySelector )

  binaryPattern = ( ^ self binarySelector , self argument )

  keywordPattern = ( ^
    ( self keyword , self argument ) plus
  )

  methodBlock = ( ^
    self NewTerm , self blockContents optional, self EndTerm
  )

  unarySelector = ( ^ self identifier )

  binarySelector = ( ^
    self Or   || self Comma || self Minus || self Equal || self Not  ||
    self And  || self Star  || self Div   || self Mod   || self Plus ||
    self More || self Less  || self At    || self Per   || self OperatorSequence
  )

  identifier = ( ^ self STPrimitive || self Identifier )

  keyword = ( ^ self Keyword )

  argument = ( ^ self variable )

  blockContents = ( ^
    ( self Or , self localDefs , self Or ) optional ,
    self blockBody
  )

  localDefs = ( ^ self variable star )

  blockBody = ( ^
    self Exit , self result ||
    (self expression , ( self Period , ((self sym: #blockBody) optional)) optional)
  )

  result = ( ^
    self expression , self Period optional
  )

  expression = ( ^ self assignation || self evaluation )

  assignation = ( ^ self assignments , self evaluation )

  assignments = ( ^ self assignment plus )

  assignment = ( ^ self variable , self Assign )

  evaluation = ( ^ self primary , self messages optional )

  primary = ( ^
    self variable            ||
    (self sym: #nestedTerm)  ||
    (self sym: #nestedBlock) ||
    self literal
  )

  variable = ( ^ self identifier )

  messages = ( ^
    (
      self unaryMessage plus ,
      self binaryMessage star ,
      self keywordMessage optional
    ) ||
    (self binaryMessage plus , self keywordMessage optional ) ||
    self keywordMessage
  )

  unaryMessage = ( ^ self unarySelector )

  binaryMessage = ( ^ self binarySelector , self binaryOperand )

  binaryOperand = ( ^ self primary , self unaryMessage star)

  keywordMessage = ( ^ ( self keyword , self formula ) plus )

  formula = ( ^ self binaryOperand , self binaryMessage star )

  nestedTerm = ( ^
    self NewTerm , (self sym: #expression) , self EndTerm
  )

  literal = ( ^
    (self sym: #literalArray) ||
    self literalSymbol        ||
    self literalString        ||
    self literalNumber
  )

  literalArray = ( ^
    self Pound ,
    self NewTerm ,
      self literal star ,
    self EndTerm
  )

  "
    Combines negative and positive Integer and Double into one symbol from
    original grammar to avoid backtracking.
  "
  literalNumber = ( ^ self Number )

  literalSymbol = ( ^ self Pound , ( self string || self selector ))

  literalString = ( ^ (self string) )

  selector = ( ^ self binarySelector || self keywordSelector || self unarySelector )

  keywordSelector = ( ^ self Keyword || self KeywordSequence )

  string = ( ^ self STString )

  nestedBlock = ( ^
    self NewBlock ,
      (self sym: #blockPattern)  optional ,
      (self sym: #blockContents) optional ,
    self EndBlock
  )

  blockPattern = ( ^ (self blockArguments) , (self Or) )

  blockArguments = ( ^ ((self Colon) , (self argument)) plus )

  Number = ( ^ self nt:
    (Literal new: '-') optional,
    self Num plus ,
    ((Literal new: '.') , self Num plus) optional
  )

  Alpha = ( ^ (Range from: 'a' to: 'z') || (Range from: 'A' to: 'Z') )

  Num = ( ^ Range from: '0' to: '9' )

  AlphaNum = ( ^ self Alpha || self Num )

  Identifier = ( ^ self nt: self Alpha , self AlphaNum star )

  STPrimitive = ( ^ self nt: 'primitive' )

  Separator = ( ^ self nt: (Repeat parser: '-' min: 4) )

  Equal    = ( ^ self nt: '='  )
  NewTerm  = ( ^ self nt: '('  )
  EndTerm  = ( ^ self nt: ')'  )
  Or       = ( ^ self nt: '|'  )
  Comma    = ( ^ self nt: ','  )
  Minus    = ( ^ self nt: '-'  )
  Not      = ( ^ self nt: '~'  )
  And      = ( ^ self nt: '&'  )
  Star     = ( ^ self nt: '*'  )
  Div      = ( ^ self nt: '/'  )
  Mod      = ( ^ self nt: '\\' )
  Plus     = ( ^ self nt: '+'  )
  More     = ( ^ self nt: '>'  )
  Less     = ( ^ self nt: '<'  )
  At       = ( ^ self nt: '@'  )
  Per      = ( ^ self nt: '%'  )
  Colon    = ( ^ self nt: ':'  )
  NewBlock = ( ^ self nt: '['  )
  EndBlock = ( ^ self nt: ']'  )
  Pound    = ( ^ self nt: '#'  )
  Exit     = ( ^ self nt: '^'  )
  Period   = ( ^ self nt: '.'  )
  Assign   = ( ^ self nt: ':=' )

  OperatorSequence = ( ^
    (
      self Not   || self And  || self Or    || self Star || self Div  ||
      self Mod   || self Plus || self Equal || self More || self Less ||
      self Comma || self At   || self Per   || self Minus
    ) plus
  )

  Keyword = ( ^ self nt: self Identifier , self Colon )

  KeywordSequence = ( ^ self Keyword plus )

  STStringChar = ( ^
    (Literal new: '\\t') ||
    '\\b'  ||
    '\\n'  ||
    '\\r'  ||
    '\\f'  ||
    '\\0'  ||
    '\\\'' ||
    '\\\\' ||
    (NotChars new: '\\\'')
  )

  STString = ( ^ self nt:
    ((Literal new: '\'') , self STStringChar star , '\'')
  )


  Comment = ( ^ (Literal new: '"') , ((NotChars new: '"') star) , '"' )

  Whitespace = ( ^ ((Literal new: ' ') || '\t' || '\r' || '\n') plus )

  SKIP = ( ^ (self Whitespace || self Comment) star )

----

)
