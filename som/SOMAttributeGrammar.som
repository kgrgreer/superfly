SOMAttributeGrammar = SOMParser (

  print: v = (
    v class = Vector ifTrue: [ v := v asArray ].
    v class = Array ifTrue: [
      '[' print.
        v do: [ :i | self print: i. ' ' print ].
      ']' print
    ] ifFalse: [
      v print
    ]
  )

  arrayToStr: a = (
    "TODO: do this more efficiently"
    a class = Vector ifTrue: [ a := a asArray ].
    ^ a inject: '' into: [ :str :elem | str + (elem asString) ]
  )


  " START OF SEMANTIC ACTIONS "

  classdef = (
    ^ super classdef action: [ :cd |
      | ast name extends fields methods |
      name    := cd at: 1.
      extends := cd at: 3.
      fields  := cd at: 5.
      methods := cd at: 6.

      ast := ASTClass new: name.
      extends ifNotNil: [ ast extends: extends ].
      fields  ifNotNil: [ ast fields:  fields ].
      methods ifNotNil: [ ast methods: methods ].

      "TODO: add someplace not C specific in future, but ok for now."
      CGenerator instance addClass: ast.

      ast
    ]
  )

  methodBlock = (
    ^ super methodBlock action: [ :mb | mb at: 2 ]
  )

  blockContents = (
    ^ super blockContents action: [ :bc | | localDefs |
      (bc at: 1) ifNil: [ localDefs := nil ] ifNotNil: [ localDefs := (bc at: 1) at: 2 ].
      Array with: localDefs with: (bc at: 2)
    ]
  )
  "
  blockBody = ( ^
    self Exit , self result ||
    (self expression , ( self Period , ((self sym: #blockBody) optional)) optional)
  )
  "

  blockBody = (
    ^ super blockBody action: [ :bb | |exp|
      bb ifNil: [ nil ]
      ifNotNil: [
        '^' = (bb at: 1) ifTrue: [
          ASTExit expr: (bb at: 2)
        ] ifFalse: [
          exp := ASTExpression expr: (bb at: 1).
          exp
        ]
      ]
    ]
  )

  method = (
    ^ super method action: [ :m |
      | ast pattern block |
      pattern := m at: 1.
      block   := m at: 3.

      ('------- block: ' + block) println.
      self print: block.
      ast := ASTMethod pattern: pattern block: block.

      ast
    ]
  )

  unaryMessage = (
    ^ super unaryMessage action: [ :u |
      ASTMessage selector: u
    ]
  )

"messages = ( ^
  (
    self unaryMessage plus ,
    self binaryMessage star ,
    self keywordMessage optional
  ) ||
  (self binaryMessage plus , self keywordMessage optional ) ||
  self keywordMessage
)"

  evaluation = (
    ^ super evaluation action: [ :e | | expr ms |
      expr := e at: 1.
      ms   := e at: 2.
"
      '----------------------------- evaluation ' println.
      self print: e.
"
      ms ifNotNil: [
      ms class = Array ifTrue: [
        ms do: [ :a |
          a do: [ :m |
            m obj: expr.
            expr := m.
          ]
        ]
      ] ifFalse: [
        ms obj: expr.
        expr := m
      ].
      ].
      expr
    ]
  )

  instanceFields = (
    ^ super instanceFields action: [ :cd |
      cd ifNil: [ nil ] ifNotNil: [
        cd at: 2
      ]
    ]
  )

  literal = (
    ^ super literal action: [ :l | ASTLiteral new: l ]
  )

  result = (
    ^ super result action: [ :r | r at: 1 ]
  )

  Identifier = (
    ^ super Identifier toStr
  )

  Number = (
    ^ super Number action: [ :a | | n |
    self print: a. '' println.
      n := ((self arrayToStr: (a at: 2)) asInteger).
      (a at: 3) ifNotNil: [ | f |
        f := 0.0 + ((self arrayToStr: ((a at: 3) at: 2)) asInteger).
        ((a at: 3) at: 2) size timesRepeat: [ f := f // 10.0 ].
        n := f + n
      ].
      (a at: 1) = '-' ifTrue: [ n := 0 - n ].
      n
    ]
  )

  literalSymbol = (
    ^ super literalSymbol toStr action: [ :s | s asSymbol ]
  )

  literalArray = (
    ^ super literalArray action: [ :a | (self print: a). a at: 1 ]
  )

  STString = (
    ^ super STString action: [ :a | self arrayToStr: (a at: 2) ]
  )

----

)
